# coding: utf8
"""
The following code contains all the routines used in the analysis of the 2D bucket lists generated by Spike.

"""
from __future__ import print_function

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm

NETMODE = 'standard' # standard / mieux / encore
def loadInt2D(epath, net=False, sym=False):
    """loads intensities from a csv bucket-list file from 2D spectra
    net: determines whether the cleaning method is used
        the method used is defined by NETMODE global
    sym: whether symetrisation is used
    """
    # lit le fichier
    ne1 = pd.read_csv( epath, header=1, sep = ', ', usecols=[0, 1, 2], engine='python')
    x1 = np.array(ne1['centerF1'])
    xu1 = np.unique(x1)
    y1 = np.array(ne1['centerF2'])
    yu1 = np.unique(y1)
    z1 = np.array(ne1['bucket'])
    # calcul la matrice
    Xr1, Yr1 = np.meshgrid(yu1, xu1)
    Zr1 = np.reshape(z1,(len(xu1),len(yu1)))
    netmode = NETMODE
    if net:
        if netmode=='standard':
            Zr1 = nettoie(Zr1)
        elif netmode=='mieux':
            Zr1 = nettoie_mieux(Zr1)
        elif netmode=='encore':
            Zr1 = nettoie_encore_mieux(Zr1)
        else:
            raise Exception(netmode + ' : Wrong netmode !')
    if sym:
            Zr1 = symetrise(Zr1)
    return [Xr1, Yr1, np.nan_to_num(Zr1)]
    
def loadStd2D(epath, net=False, sym=False):
    """loads std from a csv bucket-list file from 2D spectra
    net: determines whether the cleaning method is used
        the method used is defined by NETMODE global
    sym: whether symetrisation is used
    """
    # lit le fichier
    ne1 = pd.read_csv( epath, header=1, sep = ', ', usecols=[0, 1, 5], engine='python')
    x1 = np.array(ne1['centerF1'])
    xu1 = np.unique(x1)
    y1 = np.array(ne1['centerF2'])
    yu1 = np.unique(y1)
    z1 = np.array(ne1['std'])
    # calcul la matrice
    Xr1, Yr1 = np.meshgrid(yu1, xu1)
    Zr1 = np.reshape(z1,(len(xu1),len(yu1)))
    netmode = NETMODE
    if net:
        if netmode=='standard':
            Zr1 = nettoie(Zr1)
        elif netmode=='mieux':
            Zr1 = nettoie_mieux(Zr1)
        elif netmode=='encore':
            Zr1 = nettoie_encore_mieux(Zr1)
        else:
            raise Exception(netmode + ' : Wrong netmode !')
    if sym:
        Zr1 = symetrise(Zr1)
    return [Xr1, Yr1, np.nan_to_num(Zr1)]
    
def affiche(X, Y, Z, scale=1.0, ax=None, cmap=None, figsize=(8, 7), reverse=True):
    "draw the 2D bucket list"
    if ax is None:
        f1, ax = plt.subplots(figsize=figsize)
#    else should be a drawable matplotlib axis.
    levelbase = [0.5,1,2,5,10,20,50,100]
    m1 = Z.max()
    level = [m1*(i/100.0)/scale for i in levelbase ]
    ax.contour(X, Y, Z, level, cmap= cmap)
    ax.set_xlabel('centerF1 (ppm)')
    ax.set_ylabel('centerF2 (ppm)')
    if reverse:
        ax.invert_xaxis()
        ax.invert_yaxis()
    return ax

def symetrise(ZZ):
    "symetrisation os spectra - simple minimum operation"
    return np.minimum(ZZ, ZZ.T)
def nettoie(ZZ, factor=2.0):
    " clean noise in matrix - hard thresholding"
    ZZr = ZZ.copy()
    thresh = factor*np.median(ZZ)
    print( thresh)
    ZZr[ZZ<thresh] = 1.0   # 1.0 allows to display log(Z) !
    return ZZr
def nettoie_mieux(ZZ, factor=2.0):
    " clean noise in matrix - hard thresholding columnwise"
    ZZr = ZZ.copy()
    for i in range(ZZ.shape[1]):
        iZZ = ZZ[:,i]
        thresh = factor*np.median(iZZ)
        ZZr[iZZ<thresh,i] = 1.0
    return ZZr
def nettoie_encore_mieux(ZZ, factor=2.0):
    " clean noise in matrix - soft thresholding columnwise"
    ZZr = ZZ.copy()
    for i in range(ZZ.shape[1]):
        iZZ = ZZ[:,i]
        thresh = factor*np.median(iZZ)
        ZZr[:,i] = np.where(iZZ<thresh, 1, iZZ-thresh+1) 
    return ZZr
def compare(name, scale=1.0):
    " load and compare 2 2D bucketlists"
    g = loadStd2D(name, net=False, sym=False)
    d = loadStd2D(name, net=True, sym=True)
    levelbase = [1,2,5,10,20,50,100]
    f, (ax1, ax2) = plt.subplots(1, 2, sharey=True, sharex=True, figsize=(12,7))
    m1 = g[2].max()
    level = [m1*(i/100.0)/scale for i in levelbase ]
    ax1.contour(g[0], g[1], g[2], levels=level)

    m1 = d[2].max()
    level = [m1*(i/100.0)/scale for i in levelbase ]
    ax2.contour(d[0], d[1], d[2], level)
    ax1.invert_xaxis()
    ax1.invert_yaxis()
def normalize(Z):
    "normalise les histogrammes"
    ZZ = np.log(Z)
    mu = ZZ.mean()
    sigma = ZZ.std()
    